{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e76d105d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import sys\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.font_manager as fm\n",
    "from dotenv import load_dotenv\n",
    "from geopy.distance import geodesic\n",
    "from private.MobileMeasurements import MobileMeasurements\n",
    "\n",
    "print(\"Modules are successfully imported.\")\n",
    "print(sys.version)\n",
    "\n",
    "# 環境変数の設定\n",
    "dotenv_path: str = (\n",
    "    \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/.env\"  # .envファイル\n",
    ")\n",
    "load_dotenv(dotenv_path)\n",
    "mapbox_access_token: str | None = os.getenv(\"MAPBOX_ACCESS_TOKEN\")\n",
    "if not mapbox_access_token:\n",
    "    raise ValueError(\"MAPBOX_ACCESS_TOKEN is not set in .env file\")\n",
    "\n",
    "# ローカルフォントの読み込み（必要ない場合はコメントアウト）\n",
    "font_paths: list[str] = [\n",
    "    \"/home/connect0459/labo/py_flux_tracer/storage/assets/fonts/arial.ttf\",  # 英語のデフォルト\n",
    "    \"/home/connect0459/labo/py_flux_tracer/storage/assets/fonts/msgothic.ttc\",  # 日本語のデフォルト\n",
    "]\n",
    "for path in font_paths:\n",
    "    fm.fontManager.addfont(path)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "82bb8a9d",
   "metadata": {},
   "outputs": [],
   "source": [
    "Type = \"ultra\"\n",
    "\n",
    "\"\"\"\n",
    "複数ファイル\n",
    "\"\"\"\n",
    "aryFileName = np.array(\n",
    "    [\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.10.17/input/Pico100121_241017_092120+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.09/input/Pico100121_241109_103128.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.11/input/Pico100121_241111_091102+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.14/input/Pico100121_241114_093745+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.18/input/Pico100121_241118_092855+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.20/input/Pico100121_241120_092932+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.24/input/Pico100121_241124_092712+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.25/input/Pico100121_241125_090721+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.28/input/Pico100121_241128_090240+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.30/input/Pico100121_241130_092420+.txt\",\n",
    "        \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.12.02/input/Pico100121_241202_090316+.txt\",\n",
    "    ]\n",
    ")\n",
    "aryCodes = np.array(\n",
    "    [\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "        \"OMU2\",\n",
    "    ]\n",
    ")\n",
    "# 遅れ時間\n",
    "aryLagTime = np.array([7, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13])\n",
    "\n",
    "\"\"\"\n",
    "単一ファイル\n",
    "# \"\"\"\n",
    "# aryFileName = np.array(\n",
    "#     [\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.10.17/input/Pico100121_241017_092120+.txt\",\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.09/input/Pico100121_241109_103128.txt\",\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.11/input/Pico100121_241111_091102+.txt\",\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.14/input/Pico100121_241114_093745+.txt\",\n",
    "#         \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.18/input/Pico100121_241118_092855+.txt\",\n",
    "#         \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.20/input/Pico100121_241120_092932+.txt\",\n",
    "#         \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.24/input/Pico100121_241124_092712+.txt\",\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.25/input/Pico100121_241125_090721+.txt\",\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.28/input/Pico100121_241128_090240+.txt\",\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.11.30/input/Pico100121_241130_092420+.txt\",\n",
    "#         # \"/home/connect0459/labo/py_flux_tracer/workspace/mobile/private/data/2024.12.02/input/Pico100121_241202_090316+.txt\",\n",
    "#     ]\n",
    "# )\n",
    "# aryCodes = np.array([\"OMU2\", \"OMU2\", \"OMU2\"])\n",
    "# # 遅れ時間\n",
    "# # aryLagTime = np.array([7])\n",
    "# aryLagTime = np.array([13, 13, 13])\n",
    "\n",
    "# インスタンスの作成\n",
    "cMM = MobileMeasurements()\n",
    "cMM.read_multiple_data(aryFileName, aryCodes, Type, aryLagTime)\n",
    "\n",
    "dfData = cMM.preprocessing(window_minutes=5.0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "281be5f3-4925-45cc-9bd7-ba722b071315",
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "# cMM.plot_time_serise()\n",
    "# cMM.plot_scatter_C2C1()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b678d2a0",
   "metadata": {},
   "outputs": [],
   "source": [
    "dfData_sort = dfData.sort_values('Ultra_CH4_ppm')\n",
    "\n",
    "lat = dfData_sort['latitude']\n",
    "lon = dfData_sort['longitude']\n",
    "data = dfData.sort_values('Ultra_CH4_ppm')['Ultra_CH4_ppm'] # dfData_sort['landcover'] # \n",
    "title = \"CH₄(ppm)\"\n",
    "# title = \"\"\n",
    "cmin = 1.95\n",
    "cmax = 2.3\n",
    "\n",
    "#プレゼン用\n",
    "tick_font = 20\n",
    "label_font = 24\n",
    "\n",
    "cMM.mapbox(lat, lon, data, title, cmin, cmax, tick_font, label_font, mapbox_access_token)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "e56a2a2d-3c76-4138-80c4-284e4e13885d",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "# dfData_sort = dfData.sort_values('Ultra_CH4_ppm')\n",
    "\n",
    "# lat = dfData_sort['latitude']\n",
    "# lon = dfData_sort['longitude']\n",
    "# data = dfData.sort_values('Ultra_CH4_ppm')['Ultra_C2H6_ppb'] # dfData_sort['landcover'] # \n",
    "# title = \"C₂H₆ (ppb)\"\n",
    "# cmin = 0.0\n",
    "# cmax = 20.0\n",
    "\n",
    "# #プレゼン用\n",
    "# tick_font = 18\n",
    "# label_font = 23\n",
    "\n",
    "# cMM.mapbox(lat, lon, data, title, cmin, cmax, tick_font, label_font, mapbox_access_token)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "4154cf28-826a-4744-9088-2683787fbe10",
   "metadata": {
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "def get_unique_hotspots(\n",
    "    df_data,\n",
    "    ch4_enhance,\n",
    "    min_time_threshold_seconds=300,  # 5分以内は重複とみなす\n",
    "    max_time_threshold_hours=12.0,   # 12時間以上離れている場合は別のポイントとして扱う\n",
    "    check_time_all=True,            # 時間閾値を超えた場合の重複チェックを継続するかどうか\n",
    "    hotspot_area_meter=50.0         # 重複とみなす距離の閾値（メートル）\n",
    "):\n",
    "    \"\"\"\n",
    "    メタン濃度の増加が閾値を超えた地点から、重複を除外してユニークなホットスポットを抽出する関数\n",
    "    この実装は、MobileSpatialAnalyzer.remove_hotspots_duplicatesに基づいています。\n",
    "    \n",
    "    Remote Git Repository\n",
    "        - Commit ID: \"85f73e79cd7c7f1a1c0430e22542b3fc46d27eab\"\n",
    "        - <https://github.com/omu-meteorology/py_flux_tracer/tree/85f73e79cd7c7f1a1c0430e22542b3fc46d27eab>\n",
    "    \n",
    "    Parameters\n",
    "    ----------\n",
    "    df_data : pandas.DataFrame\n",
    "        入力データフレーム。必須カラム: \n",
    "        - Ultra_CH4_ppm\n",
    "        - Ultra_CH4_ppm_mv\n",
    "        - Ultra_CH4_ppm_delta\n",
    "        - latitude\n",
    "        - longitude\n",
    "    ch4_enhance : float\n",
    "        メタン濃度増加の閾値\n",
    "    min_time_threshold_seconds : float, optional\n",
    "        重複とみなす最小時間差（秒）\n",
    "    max_time_threshold_hours : float, optional\n",
    "        別ポイントとして扱う最大時間差（時間）\n",
    "    check_time_all : bool, optional\n",
    "        時間閾値を超えた場合の重複チェックを継続するかどうか\n",
    "    hotspot_area_meter : float, optional\n",
    "        重複とみなす距離の閾値（メートル）\n",
    "    \n",
    "    Returns\n",
    "    -------\n",
    "    pandas.DataFrame\n",
    "        ユニークなホットスポットのデータフレーム\n",
    "    \"\"\"\n",
    "    # メタン濃度の増加が閾値を超えた点を抽出\n",
    "    mask = df_data[\"Ultra_CH4_ppm\"] - df_data[\"Ultra_CH4_ppm_mv\"] > ch4_enhance\n",
    "    hotspot_candidates = df_data[mask].copy()\n",
    "    \n",
    "    # ΔCH4の降順でソート\n",
    "    sorted_hotspots = hotspot_candidates.sort_values(\n",
    "        by=\"Ultra_CH4_ppm_delta\",\n",
    "        ascending=False\n",
    "    )\n",
    "    used_positions = []\n",
    "    unique_hotspots = pd.DataFrame()\n",
    "    \n",
    "    for _, spot in sorted_hotspots.iterrows():\n",
    "        should_add = True\n",
    "        for used_lat, used_lon, used_time in used_positions:\n",
    "            # 距離チェック\n",
    "            distance = geodesic(\n",
    "                (spot.latitude, spot.longitude),\n",
    "                (used_lat, used_lon)\n",
    "            ).meters\n",
    "            \n",
    "            if distance < hotspot_area_meter:\n",
    "                # 時間差の計算（秒単位）\n",
    "                time_diff = pd.Timedelta(\n",
    "                    spot.name - pd.to_datetime(used_time)\n",
    "                ).total_seconds()\n",
    "                time_diff_abs = abs(time_diff)\n",
    "                \n",
    "                # 時間差に基づく判定\n",
    "                if check_time_all:\n",
    "                    # 時間に関係なく、距離が近ければ重複とみなす\n",
    "                    # ΔCH4が大きい方を残す（現在のスポットは必ず小さい）\n",
    "                    should_add = False\n",
    "                    break\n",
    "                else:\n",
    "                    # 時間窓による判定を行う\n",
    "                    if time_diff_abs <= min_time_threshold_seconds:\n",
    "                        # Case 1: 最小時間閾値以内は重複とみなす\n",
    "                        should_add = False\n",
    "                        break\n",
    "                    elif time_diff_abs > max_time_threshold_hours * 3600:\n",
    "                        # Case 2: 最大時間閾値を超えた場合は重複チェックをスキップ\n",
    "                        continue\n",
    "                    # Case 3: その間の時間差の場合は、距離が近ければ重複とみなす\n",
    "                    should_add = False\n",
    "                    break\n",
    "        \n",
    "        if should_add:\n",
    "            unique_hotspots = pd.concat([unique_hotspots, pd.DataFrame([spot])])\n",
    "            used_positions.append((spot.latitude, spot.longitude, spot.name))\n",
    "    \n",
    "    return unique_hotspots\n",
    "\n",
    "# ホットスポットの解析処理を実行\n",
    "unique_hotspots = get_unique_hotspots(\n",
    "    df_data=dfData,\n",
    "    ch4_enhance=cMM.ch4_enhance,\n",
    "    min_time_threshold_seconds=300,\n",
    "    max_time_threshold_hours=12.0,\n",
    "    check_time_all=True,\n",
    "    hotspot_area_meter=50.0\n",
    ")\n",
    "\n",
    "# 可視化\n",
    "lat = unique_hotspots[\"latitude\"]\n",
    "lon = unique_hotspots[\"longitude\"]\n",
    "data = unique_hotspots[\"Ultra_C2C1_ratio_delta\"]\n",
    "\n",
    "title = \"ΔC₂H₆/ΔCH₄<br>(ppb/ppm)\"\n",
    "cmin = 0.0\n",
    "cmax = 10.0\n",
    "\n",
    "cMM.mapbox(\n",
    "    lat, lon, data, title, cmin, cmax, tick_font, label_font, mapbox_access_token\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "3c9e3be8",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": ".venv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.10"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
